import type { CliConfig } from "../types/cli.js";
import { registrySchema, type Registry } from "../types/registry.js";
import fs from "fs-extra";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { createRequire } from "node:module";
import * as esbuild from "esbuild";
import { parseContentOfRegistryFile } from "../lib/registry.js";
import { checkAndCreateDirectory } from "../lib/utils.js";

async function loadConfig(): Promise<CliConfig | null> {
	const configPath = path.join(process.cwd(), "simple-shadcn.json");
	try {
		if (await fs.pathExists(configPath)) {
			const configContent = await fs.readFile(configPath, "utf-8");
			return JSON.parse(configContent);
		}

		console.error(
			"Configuration file not found. Please create a simple-shadcn.json file in your project root with the following structure:",
		);
		console.error(`{
                "outputDir": "path/to/your/output/directory",
                "registryDirectory": "path/to/your/registry/directory"
            }`);
		process.exit(1);
	} catch (error) {
		console.error("Error reading config file:", error);
		return null;
	}
}

async function importRegistry(registryDirectory: string): Promise<Registry> {
	try {
		// Look for both TypeScript and JavaScript index files
		const possibleIndexFiles = [
			path.join(registryDirectory, "index.ts"),
			path.join(registryDirectory, "index.js"),
		];

		const indexFiles = await Promise.all(
			possibleIndexFiles.map(async (file) => ({
				path: file,
				exists: await fs.pathExists(file),
			})),
		);

		const indexPath = indexFiles.find((file) => file.exists)?.path;

		if (!indexPath) {
			console.error(
				"Registry index file not found. Please create either index.ts or index.js in your registry directory.",
			);
			process.exit(1);
		}
		// Create a temporary directory for the compiled output
		const tmpDir = path.join(process.cwd(), ".simple-shadcn-tmp");
		await fs.ensureDir(tmpDir);

		const outfile = path.join(tmpDir, "registry.js");

		// Compile the TypeScript file
		await esbuild.build({
			entryPoints: [indexPath],
			bundle: true,
			platform: "node",
			format: "esm",
			outfile,
			target: "node16",
		});

		// Import the compiled file
		const registryModule = await import(pathToFileURL(outfile).href);

		// Clean up
		await fs.remove(tmpDir);

		if (!registryModule.registry) {
			console.error("Registry index file must export a 'registry' property");
			process.exit(1);
		}

		return registryModule.registry;
	} catch (error) {
		console.error("Error importing registry:", error);
		process.exit(1);
	}
}

async function addContentToRegistry(
	registry: Registry,
	registryDirectory: string,
) {
	const parsedRegistry: Registry = [];
	for (const item of registry) {
		const parsedItem = await parseContentOfRegistryFile(
			item,
			registryDirectory,
		);
		parsedRegistry.push(parsedItem);
	}
	return parsedRegistry;
}

async function createGeneratedIndexFile(registry: Registry, outputDir: string) {
	//await checkAndCreateDirectory(path.join(outputDir, "__registry__"));
	let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
export const Index: Record<string, any> = {
`;

	for (const item of registry) {
		const type = item.type.split(":")[1];

		let componentPath = `@/registry/${type}/${item.name}`;

		if (item.files) {
			if (item.files.length) {
				componentPath = `@/registry/${item.files[0].path}`;
			}
		}

		index += `	"${item.name}": {
		name: "${item.name}",
		description: "${item.description ?? ""}",
		type: "${item.type}",
		registryDependencies: ${JSON.stringify(item.registryDependencies)},
		files: [${item.files?.map((file) => {
			const filePath = `${outputDir}/${file.path}`;
			return `{
			path: "${filePath}",
			type: "${file.type}",
			target: "${file.target ?? ""}"
		}`;
		})}],
		component: React.lazy(() => import("${componentPath}")),
    },`;
	}

	index += `
}
`;

	return index;
}

async function savePublicRegistry(registry: Registry, outputDir: string) {
	await checkAndCreateDirectory(outputDir);
	for (const item of registry) {
		const outputPath = path.join(outputDir, `${item.name}.json`);
		await fs.writeFile(outputPath, JSON.stringify(item, null, 2));
	}
}

async function savePrivateRegistry(indexFile: string, outputDir: string) {
	await checkAndCreateDirectory(outputDir);
	await fs.writeFile(path.join(outputDir, "index.ts"), indexFile);
}

export async function buildCommand(): Promise<void> {
	const config = await loadConfig();
	if (!config) return;

	console.log("> Found file with config:", config);

	const importedRegistry = await importRegistry(config.registryDirectory);

	const registry = registrySchema.safeParse(importedRegistry);

	if (!registry.success) {
		console.error(registry.error);
		process.exit(1);
	}

	const registryWithContent = await addContentToRegistry(
		registry.data,
		config.registryDirectory,
	);

	/* const indexFile = await createGeneratedIndexFile(
		registryWithContent,
		config.registryDirectory,
	); */

	await savePublicRegistry(registryWithContent, config.outputDir);

	/* await savePrivateRegistry(
		indexFile,
		path.join(config.registryDirectory, "__registry__"),
	); */

	console.log(`\n> Your registry is ready to use in: ${config.outputDir}\n`);
	/* console.log(
		"Private registry saved to",
		path.join(config.registryDirectory, "__registry__"),
	); */
}
